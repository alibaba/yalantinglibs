<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.9.6"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="Doxygen Awesome"/>
    <meta property="og:image"
          content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>
    <meta property="og:description"
          content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>
    <meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/"/>
    <!-- END opengraph metadata -->
    <!-- BEGIN twitter metadata -->
    <meta name="twitter:image:src"
          content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"/>
    <meta name="twitter:title" content="Doxygen Awesome"/>
    <meta name="twitter:description"
          content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."/>
    <!-- END twitter metadata -->
    <title>yaLanTingLibs: Introduction</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript" src="toggle-alternative-theme.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
        DoxygenAwesomeDarkModeToggle.init()
        DoxygenAwesomeParagraphLink.init()
        DoxygenAwesomeInteractiveToc.init()
    </script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/alibaba/yalantinglibs" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40"
         style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }
    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
            <tr style="height: 56px;">
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">yaLanTingLibs
                    </div>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_src_coro_rpc_doc_coro_rpc_introduction__e_n.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Introduction </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>coro_rpc is a high-performance Remote Procedure Call (RPC) framework in C++20, based on stackless coroutine and compile-time reflection. In an <code>echo</code> benchmark test on localhost, it reaches a peak QPS of 20 million, which exceeds other RPC libraries, such as grpc and brpc. Rather than high performance, the most key feature of coro_rpc is easy to use: as a header-only library, it does not need to be compiled or installed separately. It allows building an RPC client and server with a few lines of C++ code.</p>
<p>The core design goal of coro_rpc is usability. Instead of exposing too many troublesome details of the underlying RPC framework, coro_rpc provides a simplifying abstraction that allows programmers to concentrate principally on business logic and implement an RPC service without much effort. Given such simplicity, coro_rpc goes back to the essence of RPC: a remote function call similar to a normal function call except for the underlying network I/O. So coro_rpc user does not need to care about the underlying networking, data serialization, and so on but focus on up-layer implementations. And coro_rpc provides simple and straightforward APIs to users. Let's see one simple demo below</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Usability</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
server</h2>
<ol type="1">
<li>define the RPC function</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// rpc_service.hpp</span></div>
<div class="line"><span class="keyword">inline</span> std::string echo(std::string str) { <span class="keywordflow">return</span> str; }</div>
</div><!-- fragment --><ol type="1">
<li>regist the RPC function and start the server</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rpc_service.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  coro_rpc_server server(<span class="comment">/*thread_num =*/</span>10, <span class="comment">/*port =*/</span>9000);</div>
<div class="line">  server.regist_handler&lt;echo&gt;(); <span class="comment">// register rpc function</span></div>
<div class="line">  server.start(); <span class="comment">// start the server and blocking wait</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Basically one could build a RPC server in 5~6 lines by defining the rpc function and starting the server, without too much details to be worried about. Now let see how a RPC client works.</p>
<p>An RPC client has to connect to the server and then call the remote method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rpc_service.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;coro_rpc/coro_rpc_client.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">Lazy&lt;void&gt; test_client() {</div>
<div class="line">  coro_rpc_client client;</div>
<div class="line">  <span class="keyword">co_await</span> client.connect(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="comment">/*port =*/</span><span class="stringliteral">&quot;9000&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> r = <span class="keyword">co_await</span> client.call&lt;echo&gt;(<span class="stringliteral">&quot;hello coro_rpc&quot;</span>); <span class="comment">// call the method with parameters</span></div>
<div class="line">  std::cout &lt;&lt; r.result.value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">//will print &quot;hello coro_rpc&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  syncAwait(test_client());</div>
<div class="line">}</div>
</div><!-- fragment --><p>As demonstrated above, it is also very convenient to build a client. There's not much difference between an RPC function call with a local function one: simply provides the function name and parameters.</p>
<p>The server/client implementation shows the usability and core features of coro_rpc. Also, it shows us the core concept of RPC: that users can invoke remote methods in a way with local functions, and users will focus their efforts on RPC functions.</p>
<p>Another usability of coro_rpc is that: there are barely any constraints on the RPC function itself. One could define an RPC function with any number of parameters of any type. The serialization/deserialization procedures are transparent to users and the RPC framework will take care of them automatically.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
RPC with any parameters</h2>
<div class="fragment"><div class="line"><span class="comment">// rpc_service.h</span></div>
<div class="line"><span class="comment">// client needs to include this header and the implementation details are hidden </span></div>
<div class="line"><span class="keywordtype">void</span> hello(){};</div>
<div class="line"><span class="keywordtype">int</span> get_value(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b){<span class="keywordflow">return</span> a + b;}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>person {</div>
<div class="line">  <span class="keywordtype">int</span> id;</div>
<div class="line">  std::string name;</div>
<div class="line">  <span class="keywordtype">int</span> age;</div>
<div class="line">};</div>
<div class="line">person get_person(person p, <span class="keywordtype">int</span> <span class="keywordtype">id</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>dummy {</div>
<div class="line">  std::string echo(std::string str) { <span class="keywordflow">return</span> str; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// rpc_service.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;rpc_service.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> get_value(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b){<span class="keywordflow">return</span> a + b;}</div>
<div class="line"> </div>
<div class="line">person get_person(person p, <span class="keywordtype">int</span> <span class="keywordtype">id</span>) {</div>
<div class="line">  p.id = id;</div>
<div class="line">  <span class="keywordflow">return</span> p;</div>
<div class="line">}</div>
</div><!-- fragment --><p>And in server, we define the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rpc_service.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  coro_rpc_server server(<span class="comment">/*thread_num =*/</span>10, <span class="comment">/*port =*/</span>9000);</div>
<div class="line"> </div>
<div class="line">  server.regist_handler&lt;hello, get_value, get_person&gt;();<span class="comment">//register the RPC functions of any signature </span></div>
<div class="line"> </div>
<div class="line">  dummy d{};</div>
<div class="line">  server.regist_handler&lt;&amp;dummy::echo&gt;(&amp;d); <span class="comment">//register the member functions</span></div>
<div class="line"> </div>
<div class="line">  server.start(); <span class="comment">// start the server</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In client, we have the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># include &quot;rpc_service.h&quot;</span></div>
<div class="line"><span class="preprocessor"># include &lt;coro_rpc/coro_rpc_client.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">Lazy&lt;void&gt; test_client() {</div>
<div class="line">  coro_rpc_client client;</div>
<div class="line">  <span class="keyword">co_await</span> client.connect(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="comment">/*port =*/</span><span class="stringliteral">&quot;9000&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//RPC invokes</span></div>
<div class="line">  <span class="keyword">co_await</span> client.call&lt;hello&gt;();</div>
<div class="line">  <span class="keyword">co_await</span> client.call&lt;get_value&gt;(1, 2);</div>
<div class="line"> </div>
<div class="line">  person p{};</div>
<div class="line">  <span class="keyword">co_await</span> client.call&lt;get_person&gt;(p, <span class="comment">/*id =*/</span>1);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> r = <span class="keyword">co_await</span> client.call&lt;&amp;dummy::echo&gt;(<span class="stringliteral">&quot;hello coro_rpc&quot;</span>);</div>
<div class="line">  std::cout &lt;&lt; r.result.value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">//will print &quot;hello coro_rpc&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  syncAwait(test_client());</div>
<div class="line">}</div>
</div><!-- fragment --><p> The input parameter and return type of <code>get_person</code> is a <code>struct</code>. The serialization/deserialization are automatically done by library <a href="https://alibaba.github.io/yalantinglibs/guide/struct-pack-intro.html">struct_pack</a> with compile-time reflection. Users are not required to take efforts on such procedures.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Compare with grpc/brpc</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Usability</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RPC   </th><th class="markdownTableHeadNone">Define DSL   </th><th class="markdownTableHeadNone">support coroutine   </th><th class="markdownTableHeadNone">code lines of hello world   </th><th class="markdownTableHeadNone">external dependency   </th><th class="markdownTableHeadNone">header-only    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">grpc   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">70+ <a href="https://github.com/grpc/grpc/tree/master/examples/cpp/helloworld">helloworld</a>   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">brpc   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">40+ <a href="https://github.com/apache/incubator-brpc/tree/master/example/asynchronous_echo_c%2B%2B">helloworld</a>   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">coro_rpc   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md6"></a>
Asynchronous Model</h2>
<p>Asynchronous callback VS. coroutine</p><ul>
<li>grpc asynchronous client</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">//&lt;https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/greeter_callback_client.cc&gt;</span></div>
<div class="line">std::string SayHello(<span class="keyword">const</span> std::string&amp; user) {</div>
<div class="line">    <span class="comment">// Data we are sending to the server.</span></div>
<div class="line">    HelloRequest request;</div>
<div class="line">    request.set_name(user);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Container for the data we expect from the server.</span></div>
<div class="line">    HelloReply reply;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Context for the client. It could be used to convey extra information to</span></div>
<div class="line">    <span class="comment">// the server and/or tweak certain RPC behaviors.</span></div>
<div class="line">    ClientContext context;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The actual RPC.</span></div>
<div class="line">    std::mutex mu;</div>
<div class="line">    std::condition_variable cv;</div>
<div class="line">    <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div>
<div class="line">    Status status;</div>
<div class="line">    stub_-&gt;async()-&gt;SayHello(&amp;context, &amp;request, &amp;reply,</div>
<div class="line">                             [&amp;mu, &amp;cv, &amp;done, &amp;status](Status s) {</div>
<div class="line">                               status = std::move(s);</div>
<div class="line">                               std::lock_guard&lt;std::mutex&gt; lock(mu);</div>
<div class="line">                               done = <span class="keyword">true</span>;</div>
<div class="line">                               cv.notify_one();</div>
<div class="line">                             });</div>
<div class="line"> </div>
<div class="line">    std::unique_lock&lt;std::mutex&gt; lock(mu);</div>
<div class="line">    <span class="keywordflow">while</span> (!done) {</div>
<div class="line">      cv.wait(lock);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Act upon its status.</span></div>
<div class="line">    <span class="keywordflow">if</span> (status.ok()) {</div>
<div class="line">      <span class="keywordflow">return</span> reply.message();</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      std::cout &lt;&lt; status.error_code() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; status.error_message()</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;RPC failed&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><ul>
<li>brpc asynchronous client <div class="fragment"><div class="line"><span class="comment">// &lt;https://github.com/apache/incubator-brpc/blob/master/example/asynchronous_echo_c%2B%2B/client.cpp&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> HandleEchoResponse(</div>
<div class="line">        brpc::Controller*cntl,</div>
<div class="line">        example::EchoResponse* response) {</div>
<div class="line">    <span class="comment">// std::unique_ptr makes sure cntl/response will be deleted before returning.</span></div>
<div class="line">    std::unique_ptr&lt;brpc::Controller&gt; cntl_guard(cntl);</div>
<div class="line">    std::unique_ptr&lt;example::EchoResponse&gt; response_guard(response);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cntl-&gt;Failed()) {</div>
<div class="line">        LOG(WARNING) &lt;&lt; <span class="stringliteral">&quot;Fail to send EchoRequest, &quot;</span> &lt;&lt; cntl-&gt;ErrorText();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Received response from &quot;</span> &lt;&lt; cntl-&gt;remote_side()</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; response-&gt;message() &lt;&lt; <span class="stringliteral">&quot; (attached=&quot;</span></div>
<div class="line">        &lt;&lt; cntl-&gt;response_attachment() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; latency=&quot;</span> &lt;&lt; cntl-&gt;latency_us() &lt;&lt; <span class="stringliteral">&quot;us&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">example::EchoService_Stub stub(&amp;channel);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send a request and wait for the response every 1 second.</span></div>
<div class="line">    <span class="keywordtype">int</span> log_id = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (!brpc::IsAskedToQuit()) {</div>
<div class="line">        <span class="comment">// Since we are sending asynchronous RPC (`done&#39; is not NULL),</span></div>
<div class="line">        <span class="comment">// these objects MUST remain valid until `done&#39; is called.</span></div>
<div class="line">        <span class="comment">// As a result, we allocate these objects on heap</span></div>
<div class="line">        example::EchoResponse* response = <span class="keyword">new</span> example::EchoResponse();</div>
<div class="line">        brpc::Controller* cntl = <span class="keyword">new</span> brpc::Controller();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Notice that you don&#39;t have to new request, which can be modified</span></div>
<div class="line">        <span class="comment">// or destroyed just after stub.Echo is called.</span></div>
<div class="line">        example::EchoRequest request;</div>
<div class="line">        request.set_message(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        cntl-&gt;set_log_id(log_id ++);  <span class="comment">// set by user</span></div>
<div class="line">        <span class="keywordflow">if</span> (FLAGS_send_attachment) {</div>
<div class="line">            <span class="comment">// Set attachment which is wired to network directly instead of </span></div>
<div class="line">            <span class="comment">// being serialized into protobuf messages.</span></div>
<div class="line">            cntl-&gt;request_attachment().append(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We use protobuf utility `NewCallback&#39; to create a closure object</span></div>
<div class="line">        <span class="comment">// that will call our callback `HandleEchoResponse&#39;. This closure</span></div>
<div class="line">        <span class="comment">// will automatically delete itself after being called once</span></div>
<div class="line">        google::protobuf::Closure* done = brpc::NewCallback(</div>
<div class="line">            &amp;HandleEchoResponse, cntl, response);</div>
<div class="line">        stub.Echo(cntl, &amp;request, response, done);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This is an asynchronous RPC, so we can only fetch the result</span></div>
<div class="line">        <span class="comment">// inside the callback</span></div>
<div class="line">        sleep(1);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>coro_rpc client with coroutine</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor"># include &lt;coro_rpc/coro_rpc_client.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">Lazy&lt;void&gt; say_hello(){</div>
<div class="line">  coro_rpc_client client;</div>
<div class="line">    <span class="keyword">co_await</span> client.connect(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="comment">/*port =*/</span><span class="stringliteral">&quot;9000&quot;</span>);</div>
<div class="line">  <span class="keywordflow">while</span> (<span class="keyword">true</span>){</div>
<div class="line">    <span class="keyword">auto</span> r = <span class="keyword">co_await</span> client.call&lt;echo&gt;(<span class="stringliteral">&quot;hello coro_rpc&quot;</span>);</div>
<div class="line">    assert(r.result.value() == <span class="stringliteral">&quot;hello coro_rpc&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>One core feature of coro_rpc is stackless coroutine where users could write asynchronous code in a synchronous manner, which is more simple and easy to understand.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
More features</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
Real-time Tasks and Non-Real-time Tasks</h2>
<p>The examples shown earlier do not demonstrate how responses are sent back to the client with the results, because by default the coro_rpc framework will help the user to serialize and send the results to client automatically. And the user is completely unaware and only needs to focus on the business logic. It should be noted that, in this scenario, the response callback is executed in the I/O thread, which is suitable for real-time critical scenarios, with the disadvantage of blocking the I/O thread. What if the user does not want to execute the business logic in the io thread, but rather in a thread or thread pool and delays sending messages?</p>
<p>coro_rpc has taken this problem into account. coro_rpc considers that RPC tasks are divided into real-time and Non-real-time tasks. real-time tasks are executed in the I/O thread and sent to the client immediately, with better timeliness and lower latency; Non-real-time tasks can be scheduled in a separate thread, and the requests are sent to the server at some point in the future; coro_rpc supports both kinds of tasks.</p>
<p>Switch to time-delayed task</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;coro_rpc/connection.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//Real-time tasks</span></div>
<div class="line">std::string echo(std::string str) { <span class="keywordflow">return</span> str; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Non-Real-time tasks, requests handled in separate thread</span></div>
<div class="line"><span class="keywordtype">void</span> delay_echo(coro_connection&lt;std::string&gt; conn, std::string str) {</div>
<div class="line">  std::thread([conn, str]{</div>
<div class="line">    conn.response_msg(str); <span class="comment">//requests handled in separate thread</span></div>
<div class="line">  }).detach();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Asynchronous mode</h2>
<p>It is recommended to use coroutine on server development. However, the asynchronous call mode is also supported if user does not prefer coroutine.</p>
<ul>
<li>coroutine based rpc server <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;coro_rpc/coro_rpc_server.hpp&gt;</span></div>
<div class="line">std::string hello() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;hello coro_rpc&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  coro_rpc_server server(<span class="comment">/*thread_num =*/</span>10, <span class="comment">/*port =*/</span>9000);</div>
<div class="line">  server.regist_handler&lt;hello&gt;();</div>
<div class="line">  server.start();</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Asynchronous rpc server</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;coro_rpc/async_rpc_server.hpp&gt;</span></div>
<div class="line">std::string hello() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;hello coro_rpc&quot;</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  async_rpc_server server(<span class="comment">/*thread_num =*/</span>10, <span class="comment">/*port =*/</span>9000);</div>
<div class="line">  server.regist_handler&lt;hello, echo&gt;();</div>
<div class="line">  server.start();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compile-time syntax checks coro_rpc does a compile-time check on the legality of the arguments when it is called, e.g.:</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> std::string echo(std::string str) { <span class="keywordflow">return</span> str; }</div>
</div><!-- fragment --><p>When client is called via:</p>
<div class="fragment"><div class="line">client.call&lt;echo&gt;(42);    <span class="comment">//Parameter mismatch, compile error</span></div>
<div class="line">client.call&lt;echo&gt;();      <span class="comment">//Missing parameters, compile error</span></div>
<div class="line">client.call&lt;echo&gt;(<span class="stringliteral">&quot;&quot;</span>, 0); <span class="comment">//Redundant parameters, compile error</span></div>
<div class="line">client.call&lt;echo&gt;(<span class="stringliteral">&quot;hello, coro_rpc&quot;</span>);<span class="comment">//Parameters match, OK</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Benchmark</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
System Configuration</h2>
<p>Processor：Intel(R) Xeon(R) Platinum 8163 CPU @2.50GHz 96Cores</p>
<p>OS: Linux version 4.9.151-015.ali3000.alios7.x86_64</p>
<p>Compiler：Alibaba Clang13 C++20</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Test case</h2>
<p>Both the client and server are on the same machine, sending requests using different amounts of connections to do echo tests.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Peak QPS test</h3>
<ol type="1">
<li>Send data and receive data through a pipeline, put CPU under full load and get the highest qps <br  />
 <img src="max_qps.png" alt="" class="inline" title="max_qps"/>    </li>
</ol>
<h3><a class="anchor" id="autotoc_md14"></a>
ping-pong test</h3>
<ol type="1">
<li>send the next request after the previous one is completed</li>
<li>check the QPS as the number of connections increases.</li>
<li>get the average latency of ping-pong <br  />
 <img src="pingpong_qps.png" alt="" class="inline" title="ping_pong_qps"/>     <img src="pingpong_time.png" alt="" class="inline" title="pingpong_time"/>    </li>
</ol>
<h3><a class="anchor" id="autotoc_md15"></a>
long-tail test</h3>
<p><img src="long_tail_qps.png" alt="" class="inline" title="long_tail_qps"/>     <img src="long_tail_time.png" alt="" class="inline" title="long_tail_time"/>    </p>
<h2><a class="anchor" id="autotoc_md16"></a>
Notes on benchmark test</h2>
<ol type="1">
<li>grpc's QPS does not exceed 100,000, so it is not included in this benchmarking.</li>
<li>The client is a coro_rpc based client for both coro_rpc and brpc stress test. It has better stress test performance compared to a brpc client(With a brpc client, the brpc client will drop 50%).</li>
<li>brpc uses connection multiplexing, The actual number of socket connections is not that high(96)</li>
</ol>
<h1><a class="anchor" id="autotoc_md17"></a>
Known Limitations</h1>
<ol type="1">
<li>Only little-endian is supported for now. Big-endian is working in progress</li>
<li>Only C++ is supported and could not work across languages now, will support other languages later; Compiler should support C++20(clang13, gcc10.2, msvc2022)</li>
<li>If any compile issue with <code>gcc -O3</code>, please try option <code>-fno-tree-slp-vectorize</code> </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
