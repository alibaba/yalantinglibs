import{_ as s,c as a,o as n,a as e}from"./app.3b6e8018.js";const t="/yalantinglibs/assets/md5_generate.0205bd46.png",A=JSON.parse('{"title":"Type system of struct_pack","description":"","frontmatter":{},"headers":[{"level":2,"title":"Basic Type","slug":"basic-type","link":"#basic-type","children":[]},{"level":2,"title":"constrained types","slug":"constrained-types","link":"#constrained-types","children":[{"level":3,"title":"container","slug":"container","link":"#container","children":[]},{"level":3,"title":"set_container","slug":"set-container","link":"#set-container","children":[]},{"level":3,"title":"map_container","slug":"map-container","link":"#map-container","children":[]},{"level":3,"title":"string","slug":"string","link":"#string","children":[]},{"level":3,"title":"array","slug":"array","link":"#array","children":[]},{"level":3,"title":"variant","slug":"variant","link":"#variant","children":[]},{"level":3,"title":"expected","slug":"expected","link":"#expected","children":[]},{"level":3,"title":"optional","slug":"optional","link":"#optional","children":[]},{"level":3,"title":"unique_ptr","slug":"unique-ptr","link":"#unique-ptr","children":[]}]},{"level":2,"title":"Struct","slug":"struct","link":"#struct","children":[{"level":3,"title":"trivial structs","slug":"trivial-structs","link":"#trivial-structs","children":[]},{"level":3,"title":"Non-trivial Structs","slug":"non-trivial-structs","link":"#non-trivial-structs","children":[]}]},{"level":2,"title":"Composite type","slug":"composite-type","link":"#composite-type","children":[]},{"level":2,"title":"Type hash checking","slug":"type-hash-checking","link":"#type-hash-checking","children":[]},{"level":2,"title":"Compatibility","slug":"compatibility","link":"#compatibility","children":[]},{"level":2,"title":"Hash conflicts","slug":"hash-conflicts","link":"#hash-conflicts","children":[]}],"relativePath":"guide/struct-pack-type-system.md","lastUpdated":null}'),p={name:"guide/struct-pack-type-system.md"},o=e(`<h1 id="type-system-of-struct-pack" tabindex="-1">Type system of struct_pack <a class="header-anchor" href="#type-system-of-struct-pack" aria-hidden="true">#</a></h1><p><code>struct_pack</code> features a non-intrusive and complete type system. It supports structs, nested structs, various basic types and various data structures, as well as serialization/deserialization of user-defined data structures. In the following we will introduce the type system of struct_pack.</p><h1 id="serialization-types-supported-by-struct-pack" tabindex="-1">Serialization types supported by struct_pack <a class="header-anchor" href="#serialization-types-supported-by-struct-pack" aria-hidden="true">#</a></h1><p>The main types supported by struct_pack are: basic types, constrained types, composite types and compatible types.</p><h2 id="basic-type" tabindex="-1">Basic Type <a class="header-anchor" href="#basic-type" aria-hidden="true">#</a></h2><p>Basic types are signed and unsigned fixed-length integers, floating-point numbers, characters, boolean types, and null types. The following table lists all the basic types supported by <code>struct_pack</code>.</p><table><thead><tr><th>Type</th><th>Meaning</th><th>code</th></tr></thead><tbody><tr><td>int8_t</td><td>Signed fixed-length 8-bit integer</td><td>complementary code</td></tr><tr><td>int16_t</td><td>Signed fixed-length 16-bit integer</td><td>complementary cod</td></tr><tr><td>int32_t</td><td>Signed fixed-length 32-bit integer</td><td>complementary cod</td></tr><tr><td>int64_t</td><td>Signed fixed-length 64-bit integer</td><td>complementary cod</td></tr><tr><td>uint8_t</td><td>Unsigned fixed-length 8-bit integer</td><td>Original Code</td></tr><tr><td>uint16_t</td><td>Unsigned fixed-length 16-bit integer</td><td>Original Code</td></tr><tr><td>uint32_t</td><td>Unsigned fixed-length 32-bit integer</td><td>Original Code</td></tr><tr><td>uint64_t</td><td>Unsigned fixed-length 64-bit integer</td><td>Original Code</td></tr><tr><td>struct_pack::var_uint32_t</td><td>Unsigned variable-length 32-bit integer</td><td><code>varint</code> variable length code</td></tr><tr><td>struct_pack::var_uint64_t</td><td>Unsigned variable-length 64-bit integer</td><td><code>varint</code> variable length code</td></tr><tr><td>struct_pack::var_int32_t</td><td>Signed variable-length 32-bit integers</td><td><code>varint</code>+<code>zigzag</code> variable length encoding</td></tr><tr><td>struct_pack::var_int64_t</td><td>Signed variable-length 64-bit integers</td><td><code>varint</code>+<code>zigzag</code> variable length encoding</td></tr><tr><td>float</td><td>Fixed-length 32-bit floating-point number</td><td>IEEE-754 single-precision encoding</td></tr><tr><td>double</td><td>Fixed-length 64-bit floating-point number</td><td>IEEE-754 double precision encoding</td></tr><tr><td>char8_t</td><td>8-bit characters</td><td>Original Code</td></tr><tr><td>char16_t</td><td>16-bit characters</td><td>Original Code</td></tr><tr><td>char32_t</td><td>32-bit characters</td><td>Original Code</td></tr><tr><td>wchar_t</td><td>wchar characters(depends on platform)</td><td>Original Code</td></tr><tr><td>bool</td><td>boolean</td><td>Original Code</td></tr><tr><td>enum/enum class</td><td>enumeration types</td><td>Original Code</td></tr><tr><td>std::monostate</td><td>empty type</td><td>N/A</td></tr></tbody></table><h2 id="constrained-types" tabindex="-1">constrained types <a class="header-anchor" href="#constrained-types" aria-hidden="true">#</a></h2><p>A constraint type is a specific data structure that satisfies a certain constraint. As long as the constraints are met, the data structure belongs to the same constraint type whether it is a class provided by the standard library or a class provided by a third-party library struct_pack supports the following constraint types.</p><table><thead><tr><th>Type Name</th><th>Meaning</th><th>Examples</th></tr></thead><tbody><tr><td>container</td><td>sequential container of elements</td><td>std::vector, std::list, std::deque, folly::flat_vector</td></tr><tr><td>set_container</td><td>set types of keys</td><td>std::set, std::unordered_set, std::multiset, boost::container::flat_set,</td></tr><tr><td>map_container</td><td>map types of key-value pairs</td><td>std::map, std::unordered_map, std::multimap, boost::container::flat_map</td></tr><tr><td>string</td><td>string</td><td>std::string, std::string_view, folly::string, boost::container::string, std::wstring, std::u8string, std::u16string, std::u32string</td></tr><tr><td>array</td><td>Array type with determined length at compile time</td><td>C built-in array, std::array</td></tr><tr><td>optional</td><td>optional</td><td>std::optional, boost::optional</td></tr><tr><td>variant</td><td>variant</td><td>std::variant</td></tr><tr><td>expected</td><td>expected, containing expected results or error codes</td><td>std::expected, tl::expected</td></tr><tr><td>unique_ptr</td><td>unique_ptr, a pointer with exclusive ownership</td><td>std::unique_ptr</td></tr></tbody></table><p>We will demonstrate the constraints for each type so that users could define data structures of their own based on such constraints.</p><h3 id="container" tabindex="-1">container <a class="header-anchor" href="#container" aria-hidden="true">#</a></h3><p><code>value_type</code>, <code>size()</code>, <code>begin()</code> and <code>end()</code> member functions should exist for this type and meanwhile it should not satisfy constraints of <code>set_container</code>, <code>map_container</code> nor <code>string</code>. <code>value_type</code> must be valid <code>struct_pack</code> type.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> container </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type container</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">value_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">begin</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">end</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">set_container </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">map_container </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> string</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>If the memory layout of this type is contiguous, <code>struct_pack</code> will enable <code>memcpy</code> optimization.</p><h3 id="set-container" tabindex="-1">set_container <a class="header-anchor" href="#set-container" aria-hidden="true">#</a></h3><p><code>value_type</code>, <code>key_type</code>, <code>size()</code>,<code>begin()</code> and <code>end()</code> member functions should be provided and <code>value_type</code> must be legal <code>struct_pcak</code> type.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> set_ontainer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type container</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">value_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">key_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">begin</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">end</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><h3 id="map-container" tabindex="-1">map_container <a class="header-anchor" href="#map-container" aria-hidden="true">#</a></h3><p><code>value_type</code>, <code>mapped_type</code>, <code>size()</code>,<code>begin()</code> and <code>end()</code> member functions should be provided and <code>value_type</code> abd <code>mapped_type</code> must be legal <code>struct_pcak</code> type.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> map_container </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type container</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">value_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">mapped_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">begin</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">end</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><h3 id="string" tabindex="-1">string <a class="header-anchor" href="#string" aria-hidden="true">#</a></h3><p><code>value_type</code> of this container must be provided of character type. Also <code>size()</code>,<code>begin()</code>,<code>end()</code>,<code>length()</code> and <code>data()</code> member functions must exist. <code>value_type</code> must be legal <code>struct_pcak</code> type.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">is_char_t</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">signed</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">char</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">char</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">unsigned</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">char</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">wchar_t</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">char16_t</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">char32_t</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">char8_t</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> string </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">  </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type container</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#F78C6C;">requires</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">is_char_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">value_type</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">begin</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">end</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">length</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">data</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>If the memory layout of the type is contiguous, struct_pack will enable memcpy optimization. When serialized to the <code>string_view</code> type, struct_pack enables zero-copy optimization.</p><h3 id="array" tabindex="-1">array <a class="header-anchor" href="#array" aria-hidden="true">#</a></h3><p>The type needs to be either a C built-in array type, or it has a <code>size()</code> member function that specializes std::tuple_size. The members of the array must also be of the legal <code>struct_pack</code> type.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> array </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">is_array_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type arr</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">arr</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">tuple_size</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">Type</span><span style="color:#89DDFF;">&gt;&gt;{};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>If the memory layout of this type is contiguous, <code>struct_pack</code> will enable <code>memcpy</code> optimization.</p><h3 id="variant" tabindex="-1">variant <a class="header-anchor" href="#variant" aria-hidden="true">#</a></h3><p>The type can only be of type <code>std::variant</code>, which is a type-safe union. The data type in <code>variant</code> must be a legal <code>struct_pack</code> types</p><h3 id="expected" tabindex="-1">expected <a class="header-anchor" href="#expected" aria-hidden="true">#</a></h3><p><code>value_type</code>, <code>error_type</code>, <code>unexpected_type</code>, <code>has_value()</code>, <code>error()</code>, and <code>value()</code> must be provided for this type. <code>value_type</code> and <code>error_type</code> must be be of the legal <code>struct_pack</code> type.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> expected </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">value_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">error_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">unexpected_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">has_value</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">error</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#F78C6C;">requires</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">is_same_v</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">void</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">                          </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">value_type</span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">Type e</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">value</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>The size of serialization result of this type depends on the maximum length of <code>value_type</code> and <code>error_type</code>.</p><h3 id="optional" tabindex="-1">optional <a class="header-anchor" href="#optional" aria-hidden="true">#</a></h3><p><code>value_type</code>, <code>has_value()</code>, <code>value</code> should be provided for this type. <code>operator *</code> should be overloaded. It should not satisfy <code>expected</code> constraints. Also <code>value_type</code> should be of legal <code>struct_pack</code> type.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> optional </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">expected</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Type</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type optional</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">optional</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">value</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">optional</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">has_value</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">optional</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">operator</span><span style="color:#89DDFF;">*();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">value_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>struct_pack will compress it if it is empty.</p><h3 id="unique-ptr" tabindex="-1">unique_ptr <a class="header-anchor" href="#unique-ptr" aria-hidden="true">#</a></h3><p>The class needs to provide: operator*, with copy assignment disabled, and the element_type member defined</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">template</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">typename</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">concept</span><span style="color:#A6ACCD;"> unique_ptr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type ptr</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">ptr</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">operator</span><span style="color:#89DDFF;">*();</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">typename</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">remove_cvref_t</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Type</span><span style="color:#89DDFF;">&gt;::</span><span style="color:#FFCB6B;">element_type</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&amp;&amp;!</span><span style="color:#F78C6C;">requires</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Type ptr</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Type ptr2</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> ptr </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> ptr2</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>If the value of this object is a null pointer, struct_pack will compress it.</p><h2 id="struct" tabindex="-1">Struct <a class="header-anchor" href="#struct" aria-hidden="true">#</a></h2><p><code>struct_pack</code> supports <code>struct</code>. Up to <strong>64</strong> fields are supported and nested fields are supported too. All members should be of valid <code>struct_pack</code> type. There are two types of <code>struct</code>:</p><h3 id="trivial-structs" tabindex="-1">trivial structs <a class="header-anchor" href="#trivial-structs" aria-hidden="true">#</a></h3><p>Ordinary structs refer to cpp <code>struct/class</code>, <code>std::pair</code> and <code>tuplet::tuple</code>.</p><p>For example:</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">person</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">int</span><span style="color:#F07178;"> age</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">string name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">pair</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">string</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#FFCB6B;">tuplet</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">tuple</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">string</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h3 id="non-trivial-structs" tabindex="-1">Non-trivial Structs <a class="header-anchor" href="#non-trivial-structs" aria-hidden="true">#</a></h3><p>This refers to std::tuples, which for historical reasons have a different memory layout than ordinary structs, and for optimization reasons we distinguish them from ordinary structs in the type system. For example:</p><p>For instance:</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">tuple</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">int</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">string</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>is a non-trivial struct.</p><h2 id="composite-type" tabindex="-1">Composite type <a class="header-anchor" href="#composite-type" aria-hidden="true">#</a></h2><p>This refers to <code>struct_pack::compatible&lt;T&gt;</code>. This is a special data type kind of identical to <code>std::optional</code> in cpp. In <code>struct_pack</code> it is dedicated for the forward/backward compatibility purpose.</p><p>All new added fields in <code>struct_pack</code> must be of <code>compatible&lt;T&gt;</code> type, so that a new type with <code>compatible&lt;T&gt;</code> could be safely deserialized to the old version of the object.</p><p>Meanwhile, data buffer of an old object, could be safely deserialized to a new version object with new <code>compatible&lt;T&gt;</code> fields defined.</p><p>For example, we updates the definition of <code>person</code>:</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">struct</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">person_v2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">int</span><span style="color:#F07178;"> age</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">string name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">struct_pack</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">compatible</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">std</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">string</span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> nick_name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>It works in the following scenarios:</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">auto</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">struct_pack</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">serialize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">person_v2{.age</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">24</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">.name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Betty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">.nick_name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">NULL</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">}</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">auto</span><span style="color:#A6ACCD;"> res </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">struct_pack</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">deserialize</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">person</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">assert</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">has_value</span><span style="color:#89DDFF;">()==true);</span></span>
<span class="line"><span style="color:#82AAFF;">assert</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">age</span><span style="color:#89DDFF;">==</span><span style="color:#F78C6C;">24</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#82AAFF;">assert</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">==</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Betty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">auto</span><span style="color:#A6ACCD;"> buffer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">struct_pack</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">serialize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">person{.age</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">24</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">.name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Betty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">}</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">auto</span><span style="color:#A6ACCD;"> res </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">struct_pack</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">deserialize</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">person_v2</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;">buffer</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">assert</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">has_value</span><span style="color:#89DDFF;">()==true);</span></span>
<span class="line"><span style="color:#82AAFF;">assert</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">age</span><span style="color:#89DDFF;">==</span><span style="color:#F78C6C;">24</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#82AAFF;">assert</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">==</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Betty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#82AAFF;">assert</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">nick_name</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">has_value</span><span style="color:#89DDFF;">()==false);</span></span>
<span class="line"></span></code></pre></div><p>NOTE: All <code>T</code> in <code>struct_pack::compatible&lt;T&gt;</code> must be legal <code>struct_pack</code> type.</p><p>For compatibility, all modified fields between versions should follow the rules:</p><ol><li>Only add new fields and all new added fields must be of type <code>struct_pack::compatible&lt;T&gt;</code></li><li>Old fields must not be modified or deleted, even it is of type <code>struct_pack::compatible&lt;T&gt;</code></li></ol><p>If compatibility is broken between versions, <code>struct_pack</code> will return an error_code safely. However, if you delete/modify the old <code>struct_pack::compatible&lt;T&gt;</code> fields, it will lead to undefined behaviors when serialize/deserialize between versions.</p><h1 id="type-information-and-type-hash" tabindex="-1">Type information and type hash <a class="header-anchor" href="#type-information-and-type-hash" aria-hidden="true">#</a></h1><h2 id="type-hash-checking" tabindex="-1">Type hash checking <a class="header-anchor" href="#type-hash-checking" aria-hidden="true">#</a></h2><p>The type-checking of struct_pack relies on the type information obtained at compile time and performs hash computation at compile time to obtain the type hash code used for checking. The steps for calculating the type hash for struct_pack are as follows:</p><ol><li>Generate a struct_pack type tree from the types to be serialized by static reflection.</li><li>Recursively traverses this tree at compile time to generate the type string corresponding to the type tree.</li><li>Compute the 32-bit MD5 hash of the string at compile time.</li></ol><p>As shown in figure:</p><p><img src="`+t+`" alt=""></p><p>Take the following structure as an example:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">struct dummy {</span></span>
<span class="line"><span style="color:#A6ACCD;">  int32_t id;</span></span>
<span class="line"><span style="color:#A6ACCD;">  double number;</span></span>
<span class="line"><span style="color:#A6ACCD;">  std::string str;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>The type tree begins with a root node of <code>struct</code>, which includes three members of <code>id</code>, <code>number</code> and <code>str</code>. Since <code>id</code> and <code>number</code> are of basic types so they are just leaf nodes in this tree. For the last member <code>str</code>, since it is a <code>string</code> constrained type, with a nested subtype of <code>char</code>, so it is a subtree with a <code>char</code> leaf.</p><p>There is an unique type <code>id</code> of each type. Such data information string could be get at compile time given the type tree. So we could get the 32-bit MD5 hash value of such type at compile time.</p><p>The checksum is stored in the header of the serialized data. When deserialization, this values is firstly read out and checked between the type information of the output data. Since the type calculation is done at compile time, such checking becomes a compare between two 32-bit integer, which is very efficient.</p><p><code>struct_pack</code> return <code>struct_pack::errc::invalid_argument</code> when type hash checking fails.</p><h2 id="compatibility" tabindex="-1">Compatibility <a class="header-anchor" href="#compatibility" aria-hidden="true">#</a></h2><p>User are allowed to add new <code>struct_pack::compatible&lt;T&gt;</code> fields on previously defined data structure. For the sack of compatibility, such fields must be skipped during type checking. In the generated type information string, subtrees whose root node is of type <code>struct_compatible&lt;T&gt;</code> will be ignored, which ensures constant hash codes between versions.</p><h2 id="hash-conflicts" tabindex="-1">Hash conflicts <a class="header-anchor" href="#hash-conflicts" aria-hidden="true">#</a></h2><p>It is possible that the 32-bit MD5 hash value conflicts in struct_pack. A hash conflict during deserialization will lead to undefined behavior of <code>struct_pack</code>. However, such possibility is extremely low. For a randomly incorrect type, such possibility is about <code>2^(-31)</code>. Considering that the probability of writing the wrong type is already low, hash conflicts should be a very rare behavior.</p><p>To mitigate hash conflicts, struct_pack by default adds full type strings and full checksums to serialized data in debug mode. Therefore, as long as the user has tested his code in debug mode, even if he accidentally writes the wrong type and is extremely unlucky to have a hash conflict, it can be detected in debug mode.</p><p>In summary, struct_pack has efficient and secure type-checking capabilities.</p>`,86),l=[o];function c(r,i,y,d,F,D){return n(),a("div",null,l)}const h=s(p,[["render",c]]);export{A as __pageData,h as default};
