/*
 * Copyright (c) 2023, Alibaba Group Holding Limited;
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once
#include <cassert>
#include <cstdint>
#include <cstring>
#include <vector>
#if defined __clang__
#define STRUCT_PB_INLINE __attribute__((always_inline)) inline
#elif defined _MSC_VER
#define STRUCT_PB_INLINE __forceinline
#else
#define STRUCT_PB_INLINE __attribute__((always_inline)) inline
#endif
#define STRUCT_PB_NODISCARD [[nodiscard]]
namespace struct_pb {

struct UnknownFields {
  STRUCT_PB_NODISCARD std::size_t total_size() const {
    std::size_t total = 0;
    for (const auto& f : fields) {
      total += f.len;
    }
    return total;
  }
  void serialize_to(char* data, std::size_t& pos, std::size_t size) const {
    for (const auto& f : fields) {
      assert(pos + f.len <= size);
      std::memcpy(data + pos, f.data, f.len);
      pos += f.len;
    }
  }
  void add_field(const char* data, std::size_t start, std::size_t end) {
    fields.push_back(Field{data + start, end - start});
  }
  struct Field {
    const char* data;
    std::size_t len;
  };
  std::vector<Field> fields;
};
/*
 * Low-Level API for struct_pb user
 * the following internal API will be generated by struct_pb protoc plugin
 */
namespace internal {
template <typename T>
STRUCT_PB_NODISCARD std::size_t get_needed_size(
    const T& t, const UnknownFields& unknown_fields = {});
template <typename T>
void serialize_to(char* data, std::size_t size, const T& t,
                  const UnknownFields& unknown_fields = {});
template <typename T>
STRUCT_PB_NODISCARD bool deserialize_to(T& t, const char* data,
                                        std::size_t size,
                                        UnknownFields& unknown_fields);
template <typename T>
STRUCT_PB_NODISCARD bool deserialize_to(T& t, const char* data,
                                        std::size_t size);
}  // namespace internal

/*
 * High-Level API for struct_pb user
 * If you need more fine-grained operations, encapsulate the internal API
 * yourself.
 */
template <typename Buffer = std::vector<char>, typename T>
STRUCT_PB_NODISCARD Buffer serialize(const T& t,
                                     const UnknownFields& unknown_fields = {}) {
  Buffer buffer;
  auto size = struct_pb::internal::get_needed_size(t, unknown_fields);
  buffer.resize(size);
  struct_pb::internal::serialize_to(buffer.data(), buffer.size(), t,
                                    unknown_fields);
  return buffer;
}
template <typename T, typename Buffer>
STRUCT_PB_NODISCARD STRUCT_PB_INLINE bool deserialize_to(
    T& t, UnknownFields& unknown_fields, const Buffer& buffer) {
  return struct_pb::internal::deserialize_to(t, buffer.data(), buffer.size(),
                                             unknown_fields);
}
template <typename T, typename Buffer>
STRUCT_PB_NODISCARD STRUCT_PB_INLINE bool deserialize_to(T& t,
                                                         const Buffer& buffer) {
  return struct_pb::internal::deserialize_to(t, buffer.data(), buffer.size());
}

}  // namespace struct_pb
